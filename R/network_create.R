#'Create social-ecological networks from raster landscapes
#'
#'@description `network_create` takes as input a raster (either real data or result of
#'  `ls_create` and derives the underlying social ecological network
#'
#'@param ls raster containing cells classified as supply, demand and neutral
#'
#'@param es_thresh distance threshold for the ecological-social links
#'
#'@param ee_thresh distance threshold for the ecological-ecological links (default value of `NULL` means no ecological-ecological links)
#'
#'@param ss_thresh distance threshold for the social-social links (default value of `NULL` means no social-social links)
#'
#'@return A list containing the network (and its attributes) and the parameters used to simulate the landscape
#'
#'@keywords ecosystem services, spatial, social ecological system, neutral landscape model
#'
#'@export
network_create <- function(x, es_thresh, ee_thresh = NULL, ss_thresh = NULL) {
  # create attribute table
  all_nodes <- raster::rasterToPolygons(x$ls, dissolve=TRUE) %>%
    raster::disaggregate() %>%
    sf::st_as_sf() %>%
    dplyr::mutate(ID = as.character(1:n()),
           patch_type = dplyr::case_when(layer == 0 ~ "supply",
                                  layer == 1 ~ "neutral",
                                  TRUE ~ "demand"),
           patch_area = st_area(.)) %>%
    dplyr::select(-layer) %>%
    dplyr::filter(patch_type != "neutral") %>%
    dplyr::mutate(patch_code = dplyr::case_when(patch_type == "supply" ~ 0,
                                  patch_type == "demand" ~ 1,
                                  TRUE ~ NaN))

  # create the social-ecological network based on ee_thresh, es_thresh, and ss_thresh (ss_thresh currently not implemented)
  # this generates a list of the node attributes (node colour) and the link presence/absence
  # between each node
  supply_nodes <- which(all_nodes$patch_type == "supply")
  demand_nodes <- which(all_nodes$patch_type == "demand")

  net_links <- sf::st_distance(all_nodes)

  net_links[supply_nodes, demand_nodes] <- ifelse(net_links[supply_nodes, demand_nodes] <= es_thresh, 1, 0)
  net_links[demand_nodes, supply_nodes] <- ifelse(net_links[demand_nodes, supply_nodes] <= es_thresh, 1, 0)

  if(!is.null(ee_thresh)) {
    net_links[supply_nodes, supply_nodes] <- ifelse(net_links[supply_nodes, supply_nodes] <= ee_thresh, 1, 0)
  } else {
    net_links[supply_nodes, supply_nodes] <- 0
  }

  if(!is.null(ss_thresh)) {
    net_links[demand_nodes, demand_nodes] <- ifelse(net_links[demand_nodes, demand_nodes] <= ee_thresh, 1, 0)
  } else {
    net_links[demand_nodes, demand_nodes] <- 0
  }

  network <- list(node_code = all_nodes$patch_code, node_type = all_nodes$patch_type, node_areas = all_nodes$patch_area, net_links = net_links)

  # create fanmod representation of discrete network - assumes bidirectionality
  # NB this is an output to file and not returned by the model
  bin_dist <- net_links
  diag(bin_dist) <- 0
  bin_dist[lower.tri(bin_dist)] <- 0
  fanmod <- tibble::as_tibble(bin_dist) %>%
    tibble::rownames_to_column(var = "int1") %>%
    tidyr::gather(key = "int2", value = "value", -int1) %>%
    dplyr::mutate(int2 = stringr::str_remove(int2, "V")) %>%
    dplyr::filter(value == 1) %>%
    dplyr::select(-value) %>%
    # get patch type (colour) for the first node
    dplyr::inner_join(tibble::as_tibble(cbind(as.character(1:length(network$node_code)), as.character(network$node_code))) %>% dplyr::select(int1 = V1, int3 = V2)) %>%
    # get patch type (colour) for the second node
    dplyr::inner_join(tibble::as_tibble(cbind(as.character(1:length(network$node_code)), as.character(network$node_code))) %>% dplyr::select(int2 = V1, int4 = V2)) %>%
    dplyr::select(int1, int2, int3, int4)

  fname = paste0("results/for_fanmod/fs_",
                 x$params['f_supply'], "_ps_", x$params['p_supply'],
                 "_fd_", x$params['f_demand'], "_pd_", x$params['p_demand'],
                 "_rep_", x$params['rep'], ".txt")

  readr::write_delim(fanmod, fname, col_names = FALSE)

  #calculate networks metrics and add to x$params
  #number of supply nodes
  x$params$num_supply <- length(which(network$node_type == "supply"))
  #number of demand nodes
  x$params$num_demand <- length(which(network$node_type == "demand"))
  #density of ecological-ecological (supply-supply) network
  if (x$params$num_supply > 1) {
    EE_network <-  network::network(as.matrix(network$net_links[which(network$node_type == "supply"), which(network$node_type == "supply")]), directed=FALSE, loops=TRUE)
    x$params$ee_density <- network::network.density(EE_network)
  } else {
    x$params$ee_density <- as.matrix(network$net_links[which(network$node_type == "supply"), which(network$node_type == "supply")])[1,1]
  }

  #density of social-ecological (demand-supply) bipartite network
  SE_matrix <- matrix(0,nrow=x$params$num_demand + x$params$num_supply, ncol=x$params$num_demand + x$params$num_supply)
  SE_matrix[1:x$params$num_demand, (x$params$num_demand + 1):ncol(SE_matrix)] <- network$net_links[which(network$node_type == "demand"), which(network$node_type == "supply")]
  SE_matrix[(x$params$num_demand + 1):nrow(SE_matrix), 1:x$params$num_demand] <- network$net_links[which(network$node_type == "supply"), which(network$node_type == "demand")]
  SE_network <-  network::network(SE_matrix, bipartite=x$params$num_demand, directed = FALSE)
  x$params$se_density <- network::network.density(SE_network, discount.bipartite=TRUE)

  return(list(network = network, params = x$params))
}
